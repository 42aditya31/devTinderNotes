
We are going to learn Node.js through out the making a real-world project, so you can understand the concepts better and also you will be able to build your own project using Node.js.

So, make notes regarding the concepts we are going to learn, so you can refer them later when you will be building your own project.

This is the project Intro file:

Project Name: DevTinder

Project Description:
DevTinder is a platform where developers can meet, connect, and collaborate on projects together. It aims to facilitate networking and project development among developers.

Project Goal:
The goal of this project is to create a fully functional web application that allows developers to create profiles, connect with other developers, and collaborate on projects. The application will be built using Node.js for the backend and React.js for the frontend.

What we going to build:
We will make using the microservices architecture, where we will have different services. Each service will be responsible for a specific functionality and will communicate with each other through APIs.

1. Frontend Service (React Js): This service will handle the user interface and user interactions. It will be built using React.js.

2. Backend Service (Node Js): This service will handle the business logic and data processing. It will be built using Node.js and will handle the business logic and data processing.

Requirements (features):

* Create an Account
* Login
* Update Profile
* Feed page: explore other developers profiles
* Send connection request
* See Our matches
* Connection request page where you can see all the connection requests you have sent and received

For now we will start with the above features and later we will add more features like chat, notifications, etc.

What do you mean by High Level Design:
High Level Design (HLD) is a design phase in software development that focuses on the architecture and structure of the system. It provides an overview of the system's components, their relationships, and how they interact with each other. HLD is typically created after the requirements gathering phase and serves as a blueprint for the detailed design phase.

What do you mean by frontend system architecture:
Frontend system architecture refers to the structure and organization of the client-side components of a web application. It defines how the user interface is built, how data flows between components, and how the application interacts with backend services. In the context of our project, the frontend architecture will be based on React.js, which allows us to create reusable components and manage the application state effectively.

Give difference between High level design and Low level design & Planning:

High Level Design (HLD):

* Focuses on the overall architecture and structure of the system.
* Provides a broad overview of the system's components, their relationships, and how they interact.
* Defines the major modules, their responsibilities, and how they communicate with each other.
* Does not go into detailed implementation specifics.
* Serves as a blueprint for the detailed design phase.

Low Level Design (LLD):

* Focuses on the detailed design of individual components and modules.
* Provides a detailed description of how each component will be implemented, including data structures, algorithms, and interfaces.
* Defines the internal logic, data flow, and interactions within each component.
* Includes specific implementation details, such as class diagrams, sequence diagrams, and database schemas.
* Serves as a guide for developers during the implementation phase.

Planning:

* Involves defining the project scope, objectives, and deliverables.
* Includes creating a project timeline, resource allocation, and risk management.
* Focuses on the overall project management aspects rather than the technical design.
* Planning is typically done before the design phases and helps ensure that the project is executed efficiently and meets its goals.

In our project, we will start with High Level Design (HLD) to outline the architecture and structure of the system, followed by Low Level Design (LLD) to detail the implementation specifics of each component. Planning will be an ongoing process throughout the project to ensure we stay on track and meet our objectives.

Tech Planning:

* Frontend: React.js
* Backend: Node.js
* Database: MongoDB (for storing user profiles and connection requests)

LLD:

DB Design (How should I think while designing the database schema, how, what, where to store the data like how to think about the collections, how to design the schema, what fields to include, what are the collections, etc.)

In our project:

Database Design:

User Collection:

* username: User's chosen username
* email: User's email address
* password: Hashed password for authentication
* profilePicture: URL of the user's profile picture
* bio: Short biography or description of the User
* age: User's age
* location: User's location
* gender: User

Connection Request Collection:

* senderId: User ID of the sender
* receiverId: User ID of the receiver
* status: Status of the connection request (e.g., ignored, pending, accepted, rejected)

What do you mean by REST API:
REST (Representational State Transfer) API is an architectural style for designing networked applications. It is based on a set of principles and constraints that allow developers to create scalable and stateless web services. REST APIs use standard HTTP methods (GET, POST, PUT, DELETE) to perform operations on resources, which are typically represented in JSON or XML format.

Real life example of REST API:

Social Media API:

A social media platform like Twitter provides a REST API that allows developers to interact with its resources, such as tweets, users, and followers.

Developers can use HTTP methods to perform actions like retrieving a user's tweets (GET), posting a new tweet (POST), updating a user's profile (PUT), or deleting a tweet (DELETE).

API Design:

Types of REST API: GET, POST, PUT, DELETE, PATCH

* GET: Retrieve data from the server (e.g., get user profile)
* POST: Send data to the server to create a new resource (e.g., create a new user)
* PUT: Update an existing resource on the server (e.g., update user profile)
* DELETE: Remove a resource from the server (e.g., delete a user account)
* PATCH: Partially update an existing resource (e.g., update only the user's bio)

What is the main difference between PUT and PATCH:

* PUT: Replaces the entire resource with the new data provided. It is idempotent, meaning multiple identical requests will have the same effect as a single request.
* PATCH: Applies partial modifications to a resource. It is not necessarily idempotent, meaning multiple identical requests may have different effects depending on the state of the resource.

Explain in detailed the CRUD operations in the API:

API Endpoints:

* Post /signup: Create a new user account
* Post /login: Authenticate a user and return a token
* GET /profile: Retrieve the user's profile information
* PUT /profile: Update the user's profile information
* Patch /profile: Partially update the user's profile information
* Post /send-connection-request: Send a connection request to another user or ignore the user
* Post /review-connection-request: Review the connection request and accept or reject it
* Get /connection-requests: Retrieve all connection requests sent and received by the user
* Get /connections: Retrieve all connections of the user

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Lets Start to build the porject :
// We will start with the backend service using Node.js and Express.js

To make initailized the porject with help of `npm init`. it will create a package.json file where we can manage our dependencies and scripts.
```bash
npm init -y # -y flag will accept all the default values
``` 
- to create the project first we have to create a server which will listen to the requests and send the response back to the client.
- We will use Express.js to create the server and handle the requests.
- Install Express.js by running the following command:
```bash         
npm install express
```


- what do you mean by Express.js:
Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features
for building web and mobile applications. It simplifies the process of creating server-side applications by providing a set of tools and utilities for routing, middleware, and request handling. Express.js is widely used in the Node.js ecosystem for building RESTful APIs and web applications.

- difference and usecase of package.json and package-lock.json:
  - package.json: This file contains metadata about the project, including its name, version, dependencies, scripts, and other configurations. It is used to manage the project's dependencies and scripts.
  - package-lock.json: This file is automatically generated when you install packages using npm. It locks the versions of the installed packages and their dependencies to ensure that the same versions are used across different environments. It helps maintain consistency in the project by preventing unexpected changes in package versions. 


- what is the use of carret sign ^ in package.json:
  - The caret (^) symbol in package.json indicates that the package manager can update the package to any minor or patch version, but not to a new major version. For example, if you have a dependency like `"express": "^4.17.1"`, it means that npm can install any version from `4.17.1` up to, but not including, `5.0.0`. This allows for automatic updates of non-breaking changes while preventing breaking changes from being installed unintentionally.
  
- what is the use of tilde sign ~ in package.json:
  - The tilde (~) symbol in package.json indicates that the package manager can update the  
package to any patch version, but not to a new minor or major version. For example, if you have a dependency like `"express": "~4.17.1"`, it means that npm can install any version from `4.17.1` up to, but not including, `4.18.0`. This allows for automatic updates of bug fixes while preventing changes that could introduce new features or breaking changes.

- what is the use of npm install --save-dev:
  - The `--save-dev` flag is used when installing a package to indicate that the package is a development dependency. This means that the package is only needed during the development phase and not in production. It will be added to the `devDependencies` section of the package.json file. For example, if you run `npm install nodemon --save-dev`, it will add nodemon as a development dependency, which is useful for automatically restarting the server during development. 

  - what is the use of npm install --save:
  - The `--save` flag is used when installing a package to indicate that the package
is a regular dependency that is required for the application to run in production. It will be added to the `dependencies` section of the package.json file. For example, if you run `npm install express --save`, it will add Express.js as a regular dependency, which is necessary for the application to function properly in production.

- what is the use of npm install --global:
  - The `--global` flag is used to install a package globally on your system, making it available for use in any project. This is typically used for command-line tools or utilities that you want to access from anywhere in your terminal. For example, if you run `npm install -g nodemon`, it will install nodemon globally, allowing you to use the `nodemon` command in any project without needing to install it locally.

  - what is the use of npm install --no-save:
  - The `--no-save` flag is used to install a package without adding it to
the `dependencies` or `devDependencies` sections of the package.json file. This is useful when you want to use a package temporarily or for testing purposes without modifying the project's dependency list. For example, if you run `npm install express --no-save`, it will install Express.js locally, but it won't be recorded in the package.json file.

- what is the use of npm install --force:
  - The `--force` flag is used to force npm to install a package even if it conflicts with existing dependencies or if there are warnings or errors. This can be useful in certain situations where you need to override npm's default behavior, but it should be used with caution as it may lead to unexpected issues in your project. For example, if you run `npm install express --force`, it will force the installation of Express.js regardless of any conflicts.
- what is the use of npm install --legacy-peer-deps:
  - The `--legacy-peer-deps` flag is used to ignore peer dependency conflicts when
installing packages. This is particularly useful when dealing with older packages that may have incompatible peer dependencies with newer versions of other packages. By using this flag, npm will install the package without enforcing strict peer dependency requirements. For example, if you run `npm install express --legacy-peer-deps`, it will install Express.js while ignoring any peer dependency conflicts that may arise.

what is the difference beyween major version, minor version and patch version:
- Major Version: The first number in a version string (e.g., `1.0   
.0`) represents the major version. A change in the major version indicates that there are significant changes or breaking changes in the API, which may require users to make adjustments to their code when upgrading.
- Minor Version: The second number in a version string (e.g., `1.1
.0`) represents the minor version. A change in the minor version indicates that new features or improvements have been added, but it is still backward compatible with the previous major version. Users can upgrade without making significant changes to their code.
- Patch Version: The third number in a version string (e.g., `1.0
.1`) represents the patch version. A change in the patch version indicates that bug fixes or minor improvements have been made without introducing new features or breaking changes. Users can safely upgrade to the latest patch version without any concerns.



 ====================================================================================================================================================================================================================================================================================================================================================================================================================================================================

 // Lets Start to build the porject :
 // we will start with making file app.js which will be the entry point of our application.
// Create a file named app.js in the root directory of your project.


```
const express = require('express');

const app = express();

app.use((req, res)=>{
    res.end("Hello from the server side!");
})
app.listen(3000,()=>{
    console.log('Server is running on port 3000'
    );  
});
```

what do you mean by request handler function:
A request handler function is a function that processes incoming HTTP requests and sends back responses. In Express
.js, request handler functions are defined to handle specific routes and HTTP methods. They take in the request object (req) and response object (res) as parameters, allowing you to access request data and send responses back to the client.
In the example above, the request handler function is defined using `app.use()`, which means it will handle all incoming requests to the server. The function takes in `req` and `res` parameters, and it sends a response back to the client with the message "Hello from the server side!".

-Explain the routing in Express.js:
Routing in Express.js refers to the process of defining how an application responds to client requests for specific
```
const express = require('express');

const app = express();

app.use("/test",(req, res)=>{
    res.send("Hello from the server side!");
})
app.listen(3000,()=>{
    console.log('Server is running on port 3000'
    );  
});const express = require('express');

const app = express();

app.use("/test",(req, res)=>{
    res.send("Hello from the server side!");
})
app.listen(3000,()=>{
    console.log('Server is running on port 3000'
    );  
});
```
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

What do you mean by gitignore file:
A `.gitignore` file is a text file used in Git repositories to specify which files or
directories should be ignored by Git when committing changes. It allows developers to exclude files that are not necessary for version control, such as temporary files, build artifacts, or sensitive information like API keys. By adding entries to the `.gitignore` file, you can prevent these files from being tracked by Git and included in the repository.




 * Routing and Request Handler in Express.js:
 

 - While we write a code : 
 ```
 app.use("/",(req, res)=>{
    res.send("Hello World");
})
 ```

 no why the output is same for all the routes:
 I mean there is any route which start with `/` so it will match all the routes and execute the request handler function.

 - Is the sequence of the routes matter:
Yes, the sequence of routes in Express.js matters. When a request is made, Express.js will check the defined routes in the order they are declared. It will execute the first matching route handler it finds. If you have a more general route (like `app.use("/")`) before a more specific route (like `app.get("/test")`), the general route will match all requests, and the specific route will never be reached. Therefore, it's important to define more specific routes before more general ones to ensure that the correct handler is executed for each request.

- explain in deatiled all things about Routes and extensions in Express.js:
In Express.js, routes are used to define how the application responds to client requests for specific endpoints. Each route is associated with a specific HTTP method (GET, POST, PUT, DELETE, etc.) and a path. When a request matches a defined route, the corresponding request handler function is executed.  
Routes can be defined using various methods provided by the Express.js framework, such as `app.get()`, `app.post()`, `app.put()`, and `app.delete()`. Each method corresponds to a specific HTTP method and allows you to handle requests accordingly.
Here are some key concepts related to routes and extensions in Express.js:
1. **Route Definition**: Routes are defined using methods like `app.get()`, `app.post()`, etc. Each method takes a path and a request handler function as arguments. For example:
   ```javascript
   app.get('/users', (req, res) => {
       res.send('List of users');
   });
   ```
2. **Route Parameters**: You can define dynamic routes using route parameters. These parameters are specified using a colon (:) in the path. For example:
   ```javascript
    app.get('/users/:id', (req, res) => {
        const userId = req.params.id;
        res.send(`User ID: ${userId}`);
    });
    ```
3. **Query Parameters**: Query parameters are used to pass additional data in the URL. They are accessed using `req.query`. For example:
    ```javascript
    app.get('/search', (req, res) => {
        const searchTerm = req.query.q;
        res.send(`Search results for: ${searchTerm}`);
    });
    ```
4. **Middleware**: Middleware functions can be used to process requests before they reach the route handler. They can perform tasks like authentication, logging, or modifying the request object. Middleware is defined using `app.use()` or as part of a specific route.
    ```javascript
    app.use((req, res, next) => {
        console.log(`Request received at ${req.url}`);
        next(); // Call the next middleware or route handler
    });
    ```
5. **Route Groups**: You can group related routes using `express.Router()`. This allows you to organize your routes better and apply middleware to a group of routes.
    ```javascript
    const router = express.Router();
    router.get('/users', (req, res) => {
        res.send('List of users');
    });
    app.use('/api', router); // Mount the router at the /api path
    ```
6. **Error Handling**: You can define error-handling middleware to catch and handle errors that occur during request processing. This middleware is defined with four parameters: `err`, `req`, `res`, and `next`.
    ```javascript
    app.use((err, req, res, next) => {
        console.error(err.stack);
        res.status(500).send('Something went wrong!');
    });
    ```
7. **Route Extensions**: Express.js allows you to extend routes with additional functionality. You can use route chaining to define multiple handlers for the same route or use route-specific middleware.
    ```javascript
    app.route('/users/:id')
        .get((req, res) => {
            res.send(`Get user with ID: ${req.params.id}`);
        })
        .put((req, res) => {
            res.send(`Update user with ID: ${req.params.id}`);
        })
        .delete((req, res) => {
            res.send(`Delete user with ID: ${req.params.id}`);
        });
    ```
8. **Static Files**: You can serve static files (like images, CSS, and JavaScript) using the `express.static()` middleware. This allows you to serve files from a specific directory.
    ```javascript
    app.use('/static', express.static('public'));
    ```
9. **Route Wildcards**: You can use wildcards to match multiple routes with a single handler. The `*` wildcard matches any path.
    ```javascript
    app.get('*', (req, res) => {
        res.send('This route matches all paths');
    });
    ```
10. **Chaining Routes**: You can chain multiple route methods for the same path to handle different HTTP methods.
    ```javascript
    app.route('/users')
        .get((req, res) => {
            res.send('Get all users');
        })
        .post((req, res) => {
            res.send('Create a new user');
        });
    ```
11. **Named Routes**: You can assign names to routes for easier reference, especially when generating URLs or redirects.
    ```javascript
    app.get('/users', (req, res) => {
        res.send('List of users');
    }).name = 'userList';
    ```
12. **Route Aliases**: You can create aliases for routes to provide alternative paths for the same functionality.
    ```javascript
    app.get('/users', (req, res) => {
        res.send('List of users');
    });
    app.get('/all-users', (req, res) => {
        res.redirect('/users'); // Redirect to the original route
    });
    ```
13. **Route Versioning**: You can version your API routes to manage changes over time without breaking existing clients.
    ```javascript
    app.get('/v1/users', (req, res) => {
        res.send('List of users in version 1');
    });
    app.get('/v2/users', (req, res) => {
        res.send('List of users in version 2');
    });
    ```
14. **Route Documentation**: It's a good practice to document your routes, especially in larger applications. You can use tools like Swagger or JSDoc to generate API documentation based on your route definitions.
    ```javascript
    /**
     * @route GET /users
     * @group Users - Operations about users
     * @returns {Array} 200 - An array of user objects
     */
    app.get('/users', (req, res) => {
        res.send('List of users');
    });
```
15. **Route Testing**: You can use testing frameworks like Mocha or Jest to write tests for your routes, ensuring that they behave as expected.
    ```javascript
    const request = require('supertest');
    const app = require('./app'); // Import your Express app

    describe('GET /users', () => {
        it('should return a list of users', (done) => {
            request(app)
                .get('/users')
                .expect(200)
                .expect('Content-Type', /json/)
                .end(done);
        });
    });
    ```
16. **Route Security**: You can implement security measures like authentication and authorization for specific routes to protect sensitive data.
    ```javascript
    const authenticate = (req, res, next) => {
        // Check if the user is authenticated
        if (req.isAuthenticated()) {
            return next();
        }
        res.status(401).send('Unauthorized');
    };
    app.get('/protected', authenticate, (req, res) => {
        res.send('This is a protected route');
    });
```
17. **Route Caching**: You can implement caching strategies for specific routes to improve performance and reduce server load.
    ```javascript
    const cache = (req, res, next) => {
        // Check if the response is cached
        const cachedResponse = getCachedResponse(req.url);
        if (cachedResponse) {
            return res.send(cachedResponse);
        }
        res.sendResponse = res.send; // Store original send method
        res.send = (body) => {
            cacheResponse(req.url, body); // Cache the response
            res.sendResponse(body); // Send the response
        };
        next();
    };
    app.get('/cached-data', cache, (req, res) => {
        res.send('This data is cached');
    });
    ```
18. **Route Rate Limiting**: You can implement rate limiting to prevent abuse of specific routes by limiting the number of requests from a single client within a certain time frame.
    ```javascript
    const rateLimit = require('express-rate-limit');
    const limiter = rateLimit({
        windowMs: 15 * 60 * 1000, // 15 minutes
        max: 100 // Limit each IP to 100 requests per windowMs
    });
    app.use('/api/', limiter); // Apply rate limiting to all API routes
    ```

    Indeatiled and simles terms 
  
    - Explain the http methods in deatiled and using the simple terms:


    - what is the main purpose of POSTMAN:
    - explain using the below exlample:
    ```
    const express = require('express');

const app = express();

// app.use("/test",(req, res)=>{
//     res.send("Hello from the Test side! This is the Test route. ");
// })
// app.use("/home",(req, res)=>{
//     res.send("Hello from the Home side! This is the Home route.");
// })

// this only call when the user use get method with user route ( to get the information of the user)
app.get("/user", (req,res)=>{
    res.send({firstName:"Aditya", lastName:"Sharma"})
})

// this is only call when the user post method with user route ( to post some details to the DB)
app.post("/user", (req,res)=>{
    // Logic for the Saving dataBase
    res.send("The data is succefully save in the database!!")
})

app.use((req, res)=>{
    res.send("Hello from the Server side! This is the default response.");
})

app.listen(3000,()=>{
    console.log('Server is running on port 3000'
    );  
});
```


----------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------


 /// Middleware & Error Handling in Express.js:

 - what do you mean by Route handler function:
 - what happend when we call any API but in the Route handler we do not pass/send in any responds?
 - what happend when we have two Route handler for single route , which one will be executed?
 - explain what happend and why and how the behind the sence its all works with the help of the given code :
```javascript
const express = require('express');

const app = express();

app.use("/user",
    (req, res, next)=>{
    // res.send("Response");
    next();
},
    (req,res)=>{
    res.send("Response 2")
}
)
app.listen(3000,()=>{
    console.log('Server is running on port 3000'
    );  
});

```
- what do you mean by next() function:
- Now in the below code :
```javascript
```javascript
const express = require('express');

const app = express();

app.use("/user",
    (req, res, next)=>{
     res.send("Response");
    next();
},
    (req,res)=>{
    res.send("Response 2")
}
)
app.listen(3000,()=>{
    console.log('Server is running on port 3000'
    );  
});
```
i am getting the response as "Response" but i am not getting the "Response 2" why?
- with that also getting error in the console as "Error: Can't set headers after they are sent." what does it mean?
- How we can more perfectly write the above code so we can not get the errors 
- what if i will  write the next function before the res.send() function, will it work or not? explain why?
- what if the first route handler function does call the next() function but the second route doesnot passed anything in the res.send() function, will it work or not? explain why?
- what if i have four-to five route handler functions for a single route, but i doesnt passed anything in the res.send() function, will it work or not? explain why?( but i am passing the next() function in all the route handler functions) 
- what if i have four-to five route handler functions for a single route, but i passed the res.send() function in all the route handler functions, will it work or not? explain why?
- why we need to create multiple route handler functions for a single route, what is the use of it?
- what do you mean by Middleware:
- what is the use of Middleware:
- what is the difference between Middleware and Route handler function:
- how we can use Middleware in Express.js:
- what is the use of Middleware in Express.js:
- Explain the below code in detail:
```javascript
const express = require('express');
const app = express();

app.use("/", (req, res, next) => {
    // res.send("Handling the / routing ");
    next();
});

app.get("/user",
(req, res, next) => {
    // res.send("Handling the /user routing ");
    next();
},
(req, res, next) => {
    // res.send("Handling the /user routing2 ");
    next();
},
(req, res, next) => {
    res.send("Handling the /user routing3 ");
    next();
});

app.listen(3000, () => {
    console.log('Server is running on port 3000');
});
```
-  what do you mean by middleware chaining:
-  what do you mean by http status codes:
-  explain the below code in detail:
```javascript
app.get("/admin/alldata",(req,res)=>{
    const token = "xyz"; // req.body?.token
    const isAdminAuthorized = token === "xyz";
    if(isAdminAuthorized){
        res.send("All the userData")
    }
    else{
        res.status(401).send("Unauthorized request !!");
    }
})
```
- what happen if there is not the token = "xyz" in the above code:
- what if we could not pass the token in the request body, how we can handle that:
- If I have multiple route handlers that require authorization, do I need to repeat the same authorization logic in each one, or is there a better way to handle it globally?
- what do you mean by middleware? why we need it: - in above senario how a middle ware can help us:
- which is the best way to used middleware in Express.js:
- what is the difference between app.use() and app.all() in Express.js:
- explain the below code in detail:
```javascript 
app.use("/admin",(req,res,next)=>{
     const token = "xyz"; // req.body?.token
    const isAdminAuthorized = token === "xyz";
    if(!isAdminAuthorized){
         res.status(401).send("Unauthorized request !!");
    }
    else{
        next();
    }
})
```
- is there any other better way for the above code to handle the authorization logic:
- explain how we can use the middleware to handle the authorization logic in a better way: using the below code :
```javascript
const express = require('express');
const app = express();
const { adminAuth } = require('./middlewares');

// Parse JSON bodies (if needed for token in req.body)
app.use(express.json());

// Apply adminAuth middleware to all /admin routes
app.use("/admin", adminAuth);

// This route is already protected by the above middleware
app.get("/admin/alldata", (req, res) => {
    res.send("All the userData");
});

// Default middleware for root (can be used for logging or other purposes)
app.use("/", (req, res, next) => {
    next();
});

// Chained handlers for /user route
app.get("/user",
    (req, res, next) => {
        next();
    },
    (req, res, next) => {
        next();
    },
    (req, res) => {
        res.send("Handling the /user routing3");
    }
);

app.listen(3000, () => {
    console.log('Server is running on port 3000');
});
```
```javascript
// middlewares/auth.js
// middlewares.js
function adminAuth(req, res, next) {
    const token = req.headers['authorization']; // or req.query.token or req.body.token
    if (token === 'xyz') {
        next();
    } else {
        res.status(401).send("Unauthorized request !!");
    }
}

module.exports = { adminAuth };
```
add this both code into notes :
```
const adminAuth = (req,res,next)=>{
     const token = "xyz"; // req.body?.token
    const isAdminAuthorized = token === "xyz";
    if(!isAdminAuthorized){
         res.status(401).send("Unauthorized request !!");
    }
    else{
        next();
    }
}

const userAuth = (req,res,next)=>{
     const token = "xyz"; // req.body?.token
    const isUserAuthorized = token === "xyz";
    if(!isUserAuthorized){
         res.status(401).send("Unauthorized request !!");
    }
    else{
        next();
    }
}

module.exports ={
    adminAuth,
    userAuth
}
```

- what do you mean by error handling middleware:
- how we can use error handling middleware in Express.js:
- explain the below code in detail:
```javascript
app.use((err, req, res, next) => {
    console.error(err.stack); // Log the error stack trace
    res.status(500).send('Something went wrong!'); // Send a generic error response
});
- what is the purpose of the `next` parameter in the error handling middleware:
- how we can use the error handling middleware in Express.js:
- what is the difference between error handling middleware and regular middleware:
- how we can use the error handling middleware in Express.js:
- explain the below code in detail:
```javascript
app.get('/error', (req, res, next) => {
    // Simulate an error
    const error = new Error('This is a simulated error');
    next(error); // Pass the error to the next middleware (error handling middleware)
});
app.use((err, req, res, next) => {
    console.error(err.stack); // Log the error stack trace
    res.status(500).send('Something went wrong!'); // Send a generic error response
});
- what is the purpose of the `next` parameter in the error handling middleware:
  - The `next` parameter in the error handling middleware is used to pass control to the next middleware function in the stack. If an error occurs, you can call `next(err)` to pass the error to the error handling middleware, which will then handle it appropriately.
- how we can use the error handling middleware in Express.js:
- also take example of the order of error handling middleware:
  - In Express.js, you can define error handling middleware by providing a function with four parameters: `err`, `req`, `res`, and `next`. This middleware should be defined after all other routes and middleware to catch any errors that occur during request processing. The order of error handling middleware matters; it should be placed after all other route handlers to ensure it can catch errors from those handlers.