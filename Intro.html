
We are going to learn Node.js through out the making a real-world project, so you can understand the concepts better and also you will be able to build your own project using Node.js.

So, make notes regarding the concepts we are going to learn, so you can refer them later when you will be building your own project.

This is the project Intro file:

Project Name: DevTinder

Project Description:
DevTinder is a platform where developers can meet, connect, and collaborate on projects together. It aims to facilitate networking and project development among developers.

Project Goal:
The goal of this project is to create a fully functional web application that allows developers to create profiles, connect with other developers, and collaborate on projects. The application will be built using Node.js for the backend and React.js for the frontend.

What we going to build:
We will make using the microservices architecture, where we will have different services. Each service will be responsible for a specific functionality and will communicate with each other through APIs.

1. Frontend Service (React Js): This service will handle the user interface and user interactions. It will be built using React.js.

2. Backend Service (Node Js): This service will handle the business logic and data processing. It will be built using Node.js and will handle the business logic and data processing.

Requirements (features):

* Create an Account
* Login
* Update Profile
* Feed page: explore other developers profiles
* Send connection request
* See Our matches
* Connection request page where you can see all the connection requests you have sent and received

For now we will start with the above features and later we will add more features like chat, notifications, etc.

What do you mean by High Level Design:
High Level Design (HLD) is a design phase in software development that focuses on the architecture and structure of the system. It provides an overview of the system's components, their relationships, and how they interact with each other. HLD is typically created after the requirements gathering phase and serves as a blueprint for the detailed design phase.

What do you mean by frontend system architecture:
Frontend system architecture refers to the structure and organization of the client-side components of a web application. It defines how the user interface is built, how data flows between components, and how the application interacts with backend services. In the context of our project, the frontend architecture will be based on React.js, which allows us to create reusable components and manage the application state effectively.

Give difference between High level design and Low level design & Planning:

High Level Design (HLD):

* Focuses on the overall architecture and structure of the system.
* Provides a broad overview of the system's components, their relationships, and how they interact.
* Defines the major modules, their responsibilities, and how they communicate with each other.
* Does not go into detailed implementation specifics.
* Serves as a blueprint for the detailed design phase.

Low Level Design (LLD):

* Focuses on the detailed design of individual components and modules.
* Provides a detailed description of how each component will be implemented, including data structures, algorithms, and interfaces.
* Defines the internal logic, data flow, and interactions within each component.
* Includes specific implementation details, such as class diagrams, sequence diagrams, and database schemas.
* Serves as a guide for developers during the implementation phase.

Planning:

* Involves defining the project scope, objectives, and deliverables.
* Includes creating a project timeline, resource allocation, and risk management.
* Focuses on the overall project management aspects rather than the technical design.
* Planning is typically done before the design phases and helps ensure that the project is executed efficiently and meets its goals.

In our project, we will start with High Level Design (HLD) to outline the architecture and structure of the system, followed by Low Level Design (LLD) to detail the implementation specifics of each component. Planning will be an ongoing process throughout the project to ensure we stay on track and meet our objectives.

Tech Planning:

* Frontend: React.js
* Backend: Node.js
* Database: MongoDB (for storing user profiles and connection requests)

LLD:

DB Design (How should I think while designing the database schema, how, what, where to store the data like how to think about the collections, how to design the schema, what fields to include, what are the collections, etc.)

In our project:

Database Design:

User Collection:

* username: User's chosen username
* email: User's email address
* password: Hashed password for authentication
* profilePicture: URL of the user's profile picture
* bio: Short biography or description of the User
* age: User's age
* location: User's location
* gender: User

Connection Request Collection:

* senderId: User ID of the sender
* receiverId: User ID of the receiver
* status: Status of the connection request (e.g., ignored, pending, accepted, rejected)

What do you mean by REST API:
REST (Representational State Transfer) API is an architectural style for designing networked applications. It is based on a set of principles and constraints that allow developers to create scalable and stateless web services. REST APIs use standard HTTP methods (GET, POST, PUT, DELETE) to perform operations on resources, which are typically represented in JSON or XML format.

Real life example of REST API:

Social Media API:

A social media platform like Twitter provides a REST API that allows developers to interact with its resources, such as tweets, users, and followers.

Developers can use HTTP methods to perform actions like retrieving a user's tweets (GET), posting a new tweet (POST), updating a user's profile (PUT), or deleting a tweet (DELETE).

API Design:

Types of REST API: GET, POST, PUT, DELETE, PATCH

* GET: Retrieve data from the server (e.g., get user profile)
* POST: Send data to the server to create a new resource (e.g., create a new user)
* PUT: Update an existing resource on the server (e.g., update user profile)
* DELETE: Remove a resource from the server (e.g., delete a user account)
* PATCH: Partially update an existing resource (e.g., update only the user's bio)

What is the main difference between PUT and PATCH:

* PUT: Replaces the entire resource with the new data provided. It is idempotent, meaning multiple identical requests will have the same effect as a single request.
* PATCH: Applies partial modifications to a resource. It is not necessarily idempotent, meaning multiple identical requests may have different effects depending on the state of the resource.

Explain in detailed the CRUD operations in the API:

API Endpoints:

* Post /signup: Create a new user account
* Post /login: Authenticate a user and return a token
* GET /profile: Retrieve the user's profile information
* PUT /profile: Update the user's profile information
* Patch /profile: Partially update the user's profile information
* Post /send-connection-request: Send a connection request to another user or ignore the user
* Post /review-connection-request: Review the connection request and accept or reject it
* Get /connection-requests: Retrieve all connection requests sent and received by the user
* Get /connections: Retrieve all connections of the user

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Lets Start to build the porject :
// We will start with the backend service using Node.js and Express.js

To make initailized the porject with help of `npm init`. it will create a package.json file where we can manage our dependencies and scripts.
```bash
npm init -y # -y flag will accept all the default values
``` 
- to create the project first we have to create a server which will listen to the requests and send the response back to the client.
- We will use Express.js to create the server and handle the requests.
- Install Express.js by running the following command:
```bash         
npm install express
```


- what do you mean by Express.js:
Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features
for building web and mobile applications. It simplifies the process of creating server-side applications by providing a set of tools and utilities for routing, middleware, and request handling. Express.js is widely used in the Node.js ecosystem for building RESTful APIs and web applications.

- difference and usecase of package.json and package-lock.json:
  - package.json: This file contains metadata about the project, including its name, version, dependencies, scripts, and other configurations. It is used to manage the project's dependencies and scripts.
  - package-lock.json: This file is automatically generated when you install packages using npm. It locks the versions of the installed packages and their dependencies to ensure that the same versions are used across different environments. It helps maintain consistency in the project by preventing unexpected changes in package versions. 


- what is the use of carret sign ^ in package.json:
  - The caret (^) symbol in package.json indicates that the package manager can update the package to any minor or patch version, but not to a new major version. For example, if you have a dependency like `"express": "^4.17.1"`, it means that npm can install any version from `4.17.1` up to, but not including, `5.0.0`. This allows for automatic updates of non-breaking changes while preventing breaking changes from being installed unintentionally.
  
- what is the use of tilde sign ~ in package.json:
  - The tilde (~) symbol in package.json indicates that the package manager can update the  
package to any patch version, but not to a new minor or major version. For example, if you have a dependency like `"express": "~4.17.1"`, it means that npm can install any version from `4.17.1` up to, but not including, `4.18.0`. This allows for automatic updates of bug fixes while preventing changes that could introduce new features or breaking changes.

- what is the use of npm install --save-dev:
  - The `--save-dev` flag is used when installing a package to indicate that the package is a development dependency. This means that the package is only needed during the development phase and not in production. It will be added to the `devDependencies` section of the package.json file. For example, if you run `npm install nodemon --save-dev`, it will add nodemon as a development dependency, which is useful for automatically restarting the server during development. 

  - what is the use of npm install --save:
  - The `--save` flag is used when installing a package to indicate that the package
is a regular dependency that is required for the application to run in production. It will be added to the `dependencies` section of the package.json file. For example, if you run `npm install express --save`, it will add Express.js as a regular dependency, which is necessary for the application to function properly in production.

- what is the use of npm install --global:
  - The `--global` flag is used to install a package globally on your system, making it available for use in any project. This is typically used for command-line tools or utilities that you want to access from anywhere in your terminal. For example, if you run `npm install -g nodemon`, it will install nodemon globally, allowing you to use the `nodemon` command in any project without needing to install it locally.

  - what is the use of npm install --no-save:
  - The `--no-save` flag is used to install a package without adding it to
the `dependencies` or `devDependencies` sections of the package.json file. This is useful when you want to use a package temporarily or for testing purposes without modifying the project's dependency list. For example, if you run `npm install express --no-save`, it will install Express.js locally, but it won't be recorded in the package.json file.

- what is the use of npm install --force:
  - The `--force` flag is used to force npm to install a package even if it conflicts with existing dependencies or if there are warnings or errors. This can be useful in certain situations where you need to override npm's default behavior, but it should be used with caution as it may lead to unexpected issues in your project. For example, if you run `npm install express --force`, it will force the installation of Express.js regardless of any conflicts.
- what is the use of npm install --legacy-peer-deps:
  - The `--legacy-peer-deps` flag is used to ignore peer dependency conflicts when
installing packages. This is particularly useful when dealing with older packages that may have incompatible peer dependencies with newer versions of other packages. By using this flag, npm will install the package without enforcing strict peer dependency requirements. For example, if you run `npm install express --legacy-peer-deps`, it will install Express.js while ignoring any peer dependency conflicts that may arise.

what is the difference beyween major version, minor version and patch version:
- Major Version: The first number in a version string (e.g., `1.0   
.0`) represents the major version. A change in the major version indicates that there are significant changes or breaking changes in the API, which may require users to make adjustments to their code when upgrading.
- Minor Version: The second number in a version string (e.g., `1.1
.0`) represents the minor version. A change in the minor version indicates that new features or improvements have been added, but it is still backward compatible with the previous major version. Users can upgrade without making significant changes to their code.
- Patch Version: The third number in a version string (e.g., `1.0
.1`) represents the patch version. A change in the patch version indicates that bug fixes or minor improvements have been made without introducing new features or breaking changes. Users can safely upgrade to the latest patch version without any concerns.



 ====================================================================================================================================================================================================================================================================================================================================================================================================================================================================

 // Lets Start to build the porject :
 // we will start with making file app.js which will be the entry point of our application.
// Create a file named app.js in the root directory of your project.


```
const express = require('express');

const app = express();

app.use((req, res)=>{
    res.end("Hello from the server side!");
})
app.listen(3000,()=>{
    console.log('Server is running on port 3000'
    );  
});
```

what do you mean by request handler function:
A request handler function is a function that processes incoming HTTP requests and sends back responses. In Express
.js, request handler functions are defined to handle specific routes and HTTP methods. They take in the request object (req) and response object (res) as parameters, allowing you to access request data and send responses back to the client.
In the example above, the request handler function is defined using `app.use()`, which means it will handle all incoming requests to the server. The function takes in `req` and `res` parameters, and it sends a response back to the client with the message "Hello from the server side!".

-Explain the routing in Express.js:
Routing in Express.js refers to the process of defining how an application responds to client requests for specific
```
const express = require('express');

const app = express();

app.use("/test",(req, res)=>{
    res.send("Hello from the server side!");
})
app.listen(3000,()=>{
    console.log('Server is running on port 3000'
    );  
});const express = require('express');

const app = express();

app.use("/test",(req, res)=>{
    res.send("Hello from the server side!");
})
app.listen(3000,()=>{
    console.log('Server is running on port 3000'
    );  
});
```
